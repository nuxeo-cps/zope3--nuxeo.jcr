.. -*- Mode: doctest -*-
.. $Id$

Basic tests
===========

We create a JCR database, except that we want one that connects to a
fake JCR repository::

    >>> import os.path
    >>> from nuxeo.jcr.db import DB
    >>> nodetypedefs = file(os.path.join(testdir, 'test_basic.cnd')).read()
    >>> class FakeDB(DB):
    ...     server = None
    ...     _nodetypedefs = nodetypedefs # Read by FakeJCRController
    >>> controller_class_name = 'nuxeo.jcr.tests.fakeserver.FakeJCRController'
    >>> db = FakeDB(controller_class_name=controller_class_name)

Then we open the database to get a connection::

    >>> from transaction import TransactionManager
    >>> tm = TransactionManager()
    >>> conn = db.open(transaction_manager=tm)
    >>> root_uuid = conn.root_uuid
    >>> root_uuid
    'cafe-babe'

Let's see what types and schemas are available, and check their classes::

    >>> sm = conn.getSchemaManager()
    >>> sorted(sm.getSchemas().keys())
    ... #doctest: +NORMALIZE_WHITESPACE
    ['ecmnt:children', 'ecmnt:document', 'ecmnt:schema',
     'ecmst:dublincore', 'ecmst:name', 'ecmst:names', 'ecmst:tripreport',
     'rep:root', 'tripreport']
    >>> sm.getClass('ecmst:name')
    <class 'nuxeo.jcr.impl.ObjectProperty'>
    >>> sm.getClass('ecmst:dublincore')
    <class 'nuxeo.jcr.impl.ObjectProperty'>
    >>> sm.getClass('tripreport')
    <class 'nuxeo.jcr.impl.Document'>

Ask the connection for the root::

    >>> root = conn.get(root_uuid)
    >>> root
    <Workspace at />
    >>> root._p_oid is root_uuid
    True
    >>> root.getUUID() is root_uuid
    True

Add a basic object to the root::

    >>> from Acquisition import aq_base
    >>> txn = tm.begin()
    >>> root._children
    <NoChildrenYet at /ecm:children>
    >>> trip = root.addChild('atrip', 'tripreport')
    >>> root._children
    <Children at /ecm:children>
    >>> root._children._p_oid
    'T1'
    >>> root['atrip']
    <Document at /atrip>
    >>> aq_base(trip) is root['atrip']
    True
    >>> trip.setProperty('dc:title', u"a trip")
    >>> trip.setProperty('name', {'first': u"Jack", 'last': u"Bauer"})
    >>> trip.setProperty('friends', [{'first': u"Chloe", 'last': u"O'Brian"},
    ...                              {'first': u"David", 'last': u"Palmer"}])
    >>> trip._p_oid # temporary oid
    'T2'
    >>> tm.commit()
    >>> trip._p_oid
    'cafe-0002'
    >>> trip._p_deactivate()

There is a child 'atrip', which is a ghost initially::

    >>> trip = root['atrip']
    >>> trip._p_changed is None
    True
    >>> trip
    <Document at /atrip>
    >>> trip._p_changed
    False

The document has a property 'dc:title'::

    >>> trip.getProperty('dc:title')
    u'a trip'

There's a complex property 'name'::

    >>> name = trip.getProperty('name')
    >>> name
    <ObjectProperty at /atrip/name>
    >>> sorted(name.getProperties().items())
    [('first', u'Jack'), ('last', u'Bauer')]

There is also a list property of friends::

    >>> friends = trip.getProperty('friends')
    >>> friends
    <ListProperty at /atrip/friends>
    >>> len(friends)
    2
    >>> list(friends)
    ... #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
    [<ObjectProperty at /atrip/friends/...>,
     <ObjectProperty at /atrip/friends/...>]
    >>> sorted(friends[0].getProperties().items())
    [('first', u'Chloe'), ('last', u"O'Brian")]
    >>> sorted(friends[1].getProperties().items())
    [('first', u'David'), ('last', u'Palmer')]

We'll check that everything gets reloaded correctly from the storage if
the persistent objects are ghostified (by the pickle cache being
reduced, or by direct invalidation).

The document itself::

    >>> trip._p_deactivate()
    >>> trip._p_activate()

An object property::

    >>> name._p_deactivate()
    >>> name._p_activate()

A list property::

    >>> friends._p_deactivate()
    >>> friends._p_activate()

An object property inside a list::

    >>> friends[0]._p_deactivate()
    >>> friends[0]._p_activate()

The "children" special node::

    >>> root._children._p_deactivate()
    >>> root._children._p_activate()

Modification
------------

Let's modify a simple property in the document. The first modification
will trigger a registration with the current transaction::

    >>> txn = tm.begin()
    >>> conn._needs_to_join, len(txn._resources)
    (True, 0)

    >>> trip._p_changed
    False
    >>> trip.setProperty('dc:title', u"Super Trip")
    >>> trip._p_changed
    True

    >>> conn._needs_to_join, len(txn._resources)
    (False, 1)

If we abort now, the modified object is invalidated and reghostified::

    >>> tm.abort()
    >>> trip._p_changed is None
    True
    >>> trip.getProperty('dc:title')
    u'a trip'

But let's really do the change and commit the modification::

    >>> txn = tm.begin()
    >>> trip.setProperty('dc:title', u"My Super Trip")
    >>> trip._p_changed
    True
    >>> tm.commit()
    >>> trip._p_changed
    False
    >>> trip.getProperty('dc:title')
    u'My Super Trip'

The property is still there, even if we deactivate the object::

    >>> trip._p_deactivate()
    >>> trip.getProperty('dc:title')
    u'My Super Trip'

Let's do this with a property that didn't exist before::

    >>> txn = tm.begin()
    >>> trip.setProperty('dc:description', u"To be done")
    >>> tm.commit()
    >>> trip.getProperty('dc:description')
    u'To be done'
    >>> trip._p_deactivate()
    >>> trip.getProperty('dc:description')
    u'To be done'

The same happens if we change a complex property::

    >>> txn = tm.begin()
    >>> name = trip.getProperty('name')
    >>> sorted(name.getProperties().items())
    [('first', u'Jack'), ('last', u'Bauer')]
    >>> name.setProperty('last', u"Shephard")
    >>> tm.commit()
    >>> name.getProperty('last')
    u'Shephard'
    >>> trip.getProperty('name') is name
    True
    >>> sorted(name.getProperties().items())
    [('first', u'Jack'), ('last', u'Shephard')]

We can also add a complex property::

    >>> txn = tm.begin()
    >>> trip.setProperty('mother', {'first': u'Number', 'last': u'5'})
    >>> mother = trip.getProperty('mother')
    >>> mother
    <ObjectProperty at /atrip/mother>
    >>> mother.getTypeName()
    'ecmst:name'
    >>> sorted(mother.getProperties().items())
    [('first', u'Number'), ('last', u'5')]
