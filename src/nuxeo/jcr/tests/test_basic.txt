.. -*- Mode: doctest -*-
.. $Id$

Basic tests
===========

We create a JCR database, except that we want one that connects to a
fake JCR repository::

    >>> import os.path
    >>> from nuxeo.jcr.db import DB
    >>> nodetypedefs = file(os.path.join(testdir, 'test_basic.cnd')).read()
    >>> class FakeDB(DB):
    ...     server = None
    ...     _nodetypedefs = nodetypedefs # Read by FakeJCRController
    >>> controller_class_name = 'nuxeo.jcr.tests.fakeserver.FakeJCRController'
    >>> db = FakeDB(controller_class_name=controller_class_name)

Then we open the database to get a connection::

    >>> from transaction import TransactionManager
    >>> tm = TransactionManager()
    >>> conn = db.open(transaction_manager=tm)
    >>> root_uuid = conn.root_uuid
    >>> root_uuid
    'cafe-babe'

Let's see what types and schemas are available, and check their classes::

    >>> sm = conn.getSchemaManager()
    >>> sorted(sm.getSchemas().keys())
    ... #doctest: +NORMALIZE_WHITESPACE
    ['ecmnt:children', 'ecmnt:document', 'ecmnt:schema',
     'ecmst:dublincore',
     'ecmst:name', 'ecmst:names',
     'ecmst:place', 'ecmst:places',
     'ecmst:tripreport',
     'rep:root', 'tripreport']
    >>> sm.getClass('ecmst:name')
    <class 'nuxeo.jcr.impl.ObjectProperty'>
    >>> sm.getClass('ecmst:dublincore')
    <class 'nuxeo.jcr.impl.ObjectProperty'>
    >>> sm.getClass('tripreport')
    <class 'nuxeo.jcr.impl.Document'>

Ask the connection for the root::

    >>> root = conn.get(root_uuid)
    >>> root
    <Workspace at />
    >>> root._p_oid is root_uuid
    True
    >>> root.getUUID() is root_uuid
    True

Add a basic object to the root::

    >>> from Acquisition import aq_base
    >>> root._children
    <NoChildrenYet at /ecm:children>
    >>> trip = root.addChild('atrip', 'tripreport')
    >>> root._children
    <Children at /ecm:children>
    >>> root._children._p_oid
    'T1'
    >>> root['atrip']
    <Document at /atrip>
    >>> aq_base(trip) is root['atrip']
    True
    >>> trip.setProperty('dc:title', u"a trip")
    >>> trip.setProperty('name', {'first': u"Jack", 'last': u"Bauer"})
    >>> trip.setProperty('friends', [{'first': u"Chloe", 'last': u"O'Brian"},
    ...                              {'first': u"David", 'last': u"Palmer"}])
    >>> trip._p_oid # temporary oid
    'T2'
    >>> tm.commit()
    >>> trip._p_oid
    'cafe-0002'
    >>> trip._p_deactivate()

There is a child 'atrip', which is a ghost initially::

    >>> trip = root['atrip']
    >>> trip._p_changed is None
    True
    >>> trip
    <Document at /atrip>
    >>> trip._p_changed
    False

The document has a property 'dc:title'::

    >>> trip.getProperty('dc:title')
    u'a trip'

There's a complex property 'name'::

    >>> name = trip.getProperty('name')
    >>> name
    <ObjectProperty at /atrip/name>
    >>> sorted(name.getProperties().items())
    [('first', u'Jack'), ('last', u'Bauer')]

There is also a list property of friends::

    >>> friends = trip.getProperty('friends')
    >>> friends
    <ListProperty at /atrip/friends>
    >>> len(friends)
    2
    >>> list(friends)
    ... #doctest: +NORMALIZE_WHITESPACE
    [<ObjectProperty at /atrip/friends/...>,
     <ObjectProperty at /atrip/friends/...>]
    >>> sorted(friends[0].getProperties().items())
    [('first', u'Chloe'), ('last', u"O'Brian")]
    >>> sorted(friends[1].getProperties().items())
    [('first', u'David'), ('last', u'Palmer')]

We'll check that everything gets reloaded correctly from the storage if
the persistent objects are ghostified (by the pickle cache being
reduced, or by direct invalidation).

The document itself::

    >>> trip._p_deactivate()
    >>> trip._p_activate()

An object property::

    >>> name._p_deactivate()
    >>> name._p_activate()

A list property::

    >>> friends._p_deactivate()
    >>> friends._p_activate()

An object property inside a list::

    >>> friends[0]._p_deactivate()
    >>> friends[0]._p_activate()

The "children" special node::

    >>> root._children._p_deactivate()
    >>> root._children._p_activate()

Modification
------------

Let's modify a simple property in the document. The first modification
will trigger a registration with the current transaction::

    >>> txn = tm.begin()
    >>> conn._needs_to_join, len(txn._resources)
    (True, 0)

    >>> trip._p_changed
    False
    >>> trip.setProperty('dc:title', u"Super Trip")
    >>> trip._p_changed
    True

    >>> conn._needs_to_join, len(txn._resources)
    (False, 1)

If we abort now, the modified object is invalidated and reghostified::

    >>> tm.abort()
    >>> trip._p_changed is None
    True
    >>> trip.getProperty('dc:title')
    u'a trip'

But let's really do the change and commit the modification::

    >>> trip.setProperty('dc:title', u"My Super Trip")
    >>> trip._p_changed
    True
    >>> tm.commit()
    >>> trip._p_changed
    False
    >>> trip.getProperty('dc:title')
    u'My Super Trip'

The property is still there, even if we deactivate the object::

    >>> trip._p_deactivate()
    >>> trip.getProperty('dc:title')
    u'My Super Trip'

Let's do this with a property that didn't exist before::

    >>> trip.setProperty('dc:description', u"To be done")
    >>> tm.commit()
    >>> trip.getProperty('dc:description')
    u'To be done'
    >>> trip._p_deactivate()
    >>> trip.getProperty('dc:description')
    u'To be done'

The same happens if we change a complex property::

    >>> name = trip.getProperty('name')
    >>> sorted(name.getProperties().items())
    [('first', u'Jack'), ('last', u'Bauer')]
    >>> name.setProperty('last', u"Shephard")
    >>> tm.commit()
    >>> name.getProperty('last')
    u'Shephard'
    >>> trip.getProperty('name') is name
    True
    >>> sorted(name.getProperties().items())
    [('first', u'Jack'), ('last', u'Shephard')]

We can also add a complex property::

    >>> trip.setProperty('mother', {'first': u'Number', 'last': u'5'})
    >>> mother = trip.getProperty('mother')
    >>> mother
    <ObjectProperty at /atrip/mother>
    >>> mother.getTypeName()
    'ecmst:name'
    >>> sorted(mother.getProperties().items())
    [('first', u'Number'), ('last', u'5')]
    >>> tm.commit()

Removal
-------

Objects can be removed from containers::

    >>> [c.getName() for c in root.getChildren()]
    ['atrip']
    >>> foo = root.addChild('foo', 'tripreport')
    >>> tm.commit()

    >>> [c.getName() for c in root.getChildren()]
    ['atrip', 'foo']
    >>> root.removeChild('foo')
    >>> [c.getName() for c in root.getChildren()]
    ['atrip']
    >>> tm.commit()

    >>> [c.getName() for c in root.getChildren()]
    ['atrip']

An abort after removal is correctly rolled back::

    >>> foo = root.addChild('foo', 'tripreport')
    >>> [c.getName() for c in root.getChildren()]
    ['atrip', 'foo']
    >>> tm.abort()
    >>> root._children._p_changed is None
    True
    >>> [c.getName() for c in root.getChildren()]
    ['atrip']

List modifications
------------------

Objects in a list can be removed::

    >>> del friends[0]
    >>> list(friends)
    [<ObjectProperty at /atrip/friends/...>]
    >>> sorted(friends[0].getProperties().items())
    [('first', u'David'), ('last', u'Palmer')]
    >>> tm.commit()

And can be reordered, as long as list elements can be matched with one
another::

    >>> trip.setProperty('places', [{'p': u'A'}, {'p': u'B'}, {'p': u'C'}])
    >>> places = trip.getProperty('places')
    >>> places
    <ListProperty at /atrip/places>
    >>> places[0]
    <ObjectProperty at /atrip/places/...>
    >>> v = places.getPythonValue()
    >>> list(sorted(v[0].keys()))
    ['__name__', 'p']

    >>> places.setPythonValue([v[2], v[1], v[0]])
    >>> [p.getProperty('p') for p in places]
    [u'C', u'B', u'A']
    >>> tm.commit()
    >>> places._p_deactivate() # check it reloads ok
    >>> [p.getProperty('p') for p in places]
    [u'C', u'B', u'A']

    >>> n = [i.getName() for i in places]
    >>> places.reorder([n[2], n[0], n[1]])
    >>> [p.getProperty('p') for p in places]
    [u'A', u'C', u'B']
    >>> tm.abort()
    >>> places._p_changed is None
    True
    >>> [p.getProperty('p') for p in places]
    [u'C', u'B', u'A']


Sanity checks
-------------

You can't add two objects with the same name to a container::

    >>> root.addChild('atrip', 'tripreport')
    Traceback (most recent call last):
      ...
    KeyError: "Child 'atrip' already exists"
    >>> tm.abort()

You can't remove a nonexisting child from a container::

    >>> root.removeChild('bobo')
    Traceback (most recent call last):
      ...
    KeyError: 'bobo'
    >>> tm.abort()

